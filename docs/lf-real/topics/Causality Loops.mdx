---
title: "Causality Loops"
layout: docs
permalink: /docs/handbook/causality-loops
oneline: "Causality loops in Lingua Franca."
preamble: >
---

import {
  LanguageSelector,
  NoSelectorTargetCodeBlock,
  ShowIf, ShowIfs, ShowOnly
} from '@site/src/components/LinguaFrancaMultiTargetUtils';

<LanguageSelector c cpp py rs ts />

## Cycles

The interconnection pattern for a collection of reactors can form a cycle, but some care is required. Consider the following example:

import C_Cycle from '../code/c/src/Cycle.lf';
import Cpp_Cycle from '../code/cpp/src/Cycle.lf';
import Py_Cycle from '../code/py/src/Cycle.lf';
import Rs_Cycle from '../code/rs/src/Cycle.lf';
import TS_Cycle from '../code/ts/src/Cycle.lf';

<NoSelectorTargetCodeBlock c={C_Cycle} cpp={Cpp_Cycle} py={Py_Cycle} rs={Rs_Cycle} ts={TS_Cycle} lf />

This program yields the following diagram:

<img alt="Lingua Franca diagram" src="../../img/diagrams/Cycle.svg" width="400"/>

The diagram highlights a **causality loop** in the program. At each tag, in reactor `B`, the first reaction has to execute before the second if it is enabled, a precedence indicated with the red dashed arrow. But the first can't execute until the reaction of `A` has executed, and that reaction cannot execute until the second reaction `B` has executed. There is no way to satisfy these requirements, so the tools refuse to generated code.

## Cycles with Delays

One way to break the causality loop and get an executable program is to introduce a [logical delay](<../topics/Composing Reactors.mdx#connections-with-logical-delays>) into the loop, as shown below:

import C_CycleWithDelay from '../code/c/src/CycleWithDelay.lf';
import Cpp_CycleWithDelay from '../code/cpp/src/CycleWithDelay.lf';
import Py_CycleWithDelay from '../code/py/src/CycleWithDelay.lf';
import Rs_CycleWithDelay from '../code/rs/src/CycleWithDelay.lf';
import TS_CycleWithDelay from '../code/ts/src/CycleWithDelay.lf';

<NoSelectorTargetCodeBlock c={C_CycleWithDelay} cpp={Cpp_CycleWithDelay} py={Py_CycleWithDelay} rs={Rs_CycleWithDelay} ts={TS_CycleWithDelay} lf />

<img alt="Lingua Franca diagram" src="../../img/diagrams/CycleWithDelay.svg" width="400"/>

Here, we have used a delay of 0, which results in a delay of one [microstep](<../topics/Superdense Time.mdx>). We could equally well have specified a positive time value.

## Reaction Order

Frequently, a program will have such cycles, but you don't want a logical delay in the loop. To get a cycle without logical delays, the reactions need to be reordered, as shown below:

import C_CycleReordered from '../code/c/src/CycleReordered.lf';
import Cpp_CycleReordered from '../code/cpp/src/CycleReordered.lf';
import Py_CycleReordered from '../code/py/src/CycleReordered.lf';
import Rs_CycleReordered from '../code/rs/src/CycleReordered.lf';
import TS_CycleReordered from '../code/ts/src/CycleReordered.lf';

<NoSelectorTargetCodeBlock c={C_CycleReordered} cpp={Cpp_CycleReordered} py={Py_CycleReordered} rs={Rs_CycleReordered} ts={TS_CycleReordered} lf />

<img alt="Lingua Franca diagram" src="../../img/diagrams/CycleReordered.svg" width="400"/>

There is no longer any causality loop.
